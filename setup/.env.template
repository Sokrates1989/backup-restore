# Centralized Python Version Configuration
# Copy this file to .env and customize as needed

# Python version to use across all environments
# This version will be used in both Dockerfiles and should match your project requirements
PYTHON_VERSION=3.13

# =============================================================================
# DOCKER IMAGE CONFIGURATION (for production builds)
# =============================================================================
# Docker image name for production deployments
# Format: username/repository-name or registry.example.com/repository-name
# Example: sokrates1989/my-api or ghcr.io/username/my-api
IMAGE_NAME=sokrates1989/backup-restore

# Docker image version/tag
# This will be prompted during build if not set or if you want to update it
# Format: semantic versioning recommended (e.g., 1.0.0, 1.2.3, v2.0.0)
# The build script will update this value when you build a new image
IMAGE_VERSION=0.0.1

# Image tag baked into the running container and web UI (version.json)
# - Use "dev" for local development
# - For production builds, build-image scripts typically set this to IMAGE_VERSION
IMAGE_TAG=dev

# Database Configuration
# Supported types: neo4j, postgresql, mysql, sqlite
DB_TYPE=postgresql

# Database Mode: local (Docker) or standalone (app-only, connects to existing database)
# - local: Starts database in Docker (uses docker-compose.neo4j.yml or docker-compose.postgres.yml)
# - standalone: Runs only the API container, no local DB container (use external DB connection)
DB_MODE=local

# =============================================================================
# DATABASE CREDENTIALS - IMPORTANT SECURITY NOTES
# =============================================================================
# ⚠️  WARNING: These credentials are for LOCAL DEVELOPMENT ONLY!
# ⚠️  NEVER use these default passwords in production!
# ⚠️  For production, use Docker secrets, environment variables from secure vaults,
#     or managed database services with strong, unique passwords.
#
# DB_USER and DB_PASSWORD are ONLY used for:
# 1. Neo4j databases (both local Docker and external)
# 2. Setting up local Docker databases (PostgreSQL/MySQL containers)
# 3. External database connections (if credentials are in DATABASE_URL)
#
# For local PostgreSQL/MySQL Docker containers:
# - These values set the initial database user/password when container is created
# - They must match the credentials in DATABASE_URL
# - Default PostgreSQL: user=postgres, password=postgres
# - Default MySQL: user=root, password=password
#
# For production:
# - Use Docker secrets: https://docs.docker.com/engine/swarm/secrets/
# - Use environment variables from secure key vaults (AWS Secrets Manager, Azure Key Vault, etc.)
# - Use managed database services with IAM authentication
# - Generate strong, unique passwords (20+ characters, mixed case, numbers, symbols)
# =============================================================================

# Neo4j Configuration (used when DB_TYPE=neo4j)
# For local Docker: bolt://neo4j:7687 (Docker service name)
# For external: bolt://your-server:7687 (external server)
# IMPORTANT: Use 'neo4j' (service name) for Docker Compose, use 'localhost' for external access
# IMPORTANT: Neo4j requires username to be 'neo4j'
NEO4J_URL=bolt://neo4j:7687
NEO4J_HTTP_PORT=7474

# SQL Database Configuration (used when DB_TYPE=postgresql, mysql, or sqlite)
# For local Docker PostgreSQL: postgresql://postgres:postgres@postgres:5432/apidb
# For local Docker MySQL: mysql://root:password@mysql:3306/apidb
# For external: postgresql://user:password@your-server:5432/dbname
# For SQLite: sqlite:///./database.db (no credentials needed)
#
# NOTE: For local Docker, you can either:
# 1. Set DATABASE_URL with full connection string (legacy)
# 2. Set DB_HOST, DB_USER, DB_PASSWORD, DB_NAME, DB_PORT separately (recommended)
#    The application will build the URL automatically
#
# IMPORTANT: Use service names (postgres) for Docker Compose, use localhost for external access
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/apidb
DB_HOST=postgres
DB_NAME=apidb
DB_USER=postgres
DB_PASSWORD=postgres
DB_PORT=5432

# Api Settings.
PORT=8000

# Web UI (nginx) Settings
# The web container serves the GUI and proxies API requests.
# Default 8086 to avoid collisions with test-db admin UIs (e.g. phpMyAdmin uses 8080).
WEB_PORT=8086

# Enable debug features (True/False).
DEBUG=true


# =============================================================================
# SECURITY CONFIGURATION - KEYCLOAK (OIDC)
# =============================================================================
# The backup-restore service uses Keycloak-only authentication (JWT bearer tokens).
# Configure these values for both the API and the web UI containers.
#
# KEYCLOAK_URL is used for issuer validation (public URL).
# KEYCLOAK_INTERNAL_URL is used for JWKS/token endpoints inside Docker.
# If Keycloak runs on the host, use http://host.docker.internal:9090 on macOS/Windows.
#
# For the backend service, KEYCLOAK_CLIENT_ID should match the confidential client
# (e.g., backup-restore-backend). For the web UI container, set KEYCLOAK_CLIENT_ID
# to the public client (e.g., backup-restore-frontend) in the web service env.
# =============================================================================
KEYCLOAK_ENABLED=true
KEYCLOAK_URL=http://localhost:9090
KEYCLOAK_INTERNAL_URL=http://host.docker.internal:9090
KEYCLOAK_REALM=backup-restore
KEYCLOAK_CLIENT_ID=backup-restore-backend
KEYCLOAK_CLIENT_SECRET=
KEYCLOAK_FRONTEND_CLIENT_ID=backup-restore-frontend


# =============================================================================
# AUTOMATION SECRETS ENCRYPTION (required to store passwords in the DB)
# =============================================================================
# The automation feature can store "secrets" (like DB passwords, SFTP passwords,
# Google Drive service account JSON) encrypted at rest in the SQL database.
#
# If CONFIG_ENCRYPTION_KEY is NOT configured, creating/updating a target/destination
# with secrets will fail with:
#   "Secrets provided but CONFIG_ENCRYPTION_KEY is not configured"
#
# You can set either:
# - CONFIG_ENCRYPTION_KEY: A strong random string (recommended)
# - CONFIG_ENCRYPTION_KEY_FILE: Path to a file containing the key (Docker secrets)
#
# Key generation example:
#   python -c "import secrets; print(secrets.token_urlsafe(32))"
CONFIG_ENCRYPTION_KEY=
CONFIG_ENCRYPTION_KEY_FILE=


# =============================================================================
# NOTIFICATION CONFIGURATION (for backup status alerts)
# =============================================================================
# Telegram notifications require a bot token.
# Create a bot via @BotFather on Telegram and get the token.
# Get your chat_id by messaging @userinfobot or @getidsbot
#
# Email notifications require SMTP configuration.
# For Gmail: use app passwords (https://support.google.com/accounts/answer/185833)
# =============================================================================

# Telegram Bot Token (get from @BotFather)
# Can also use TELEGRAM_BOT_TOKEN_FILE for Docker secrets
TELEGRAM_BOT_TOKEN=
TELEGRAM_BOT_TOKEN_FILE=

# SMTP Configuration for Email Notifications
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASSWORD=
SMTP_PASSWORD_FILE=
SMTP_FROM=
SMTP_USE_TLS=true
